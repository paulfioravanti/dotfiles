# Template-related snippets needed for inline heex templates
extends html
extends eelixir

global !p

# ~/.vim/pythonx/elixir_helpers.py
from elixir_helpers import closing_character

def key_closing(opening):
    return "\" =>" if opening == "\"" else ":"

endglobal

snippet exception "Exception.exception/1"
@impl true
def exception(${1:term}) do
  $0
end
endsnippet

snippet "(?:IO )?inspect" "IO.inspect/2" r
IO.inspect(${1:item}${2:, ${3:opts}})$0
endsnippet

snippet key-value "Key-value pair"
${1:"}${2:key}`!p snip.rv = key_closing(t[1])` ${3:$2}$0
endsnippet

snippet keyword "Literal Elixir keyword list"
${1:[}${2:key}: ${3:value}$0`!p snip.rv = closing_character(t[1])`
endsnippet

snippet list "Literal Elixir list"
[$0]
endsnippet

snippet map "Literal Elixir map" i
%{${1:"}${2:key}`!p snip.rv = key_closing(t[1])` ${3:$2}$0}
endsnippet

snippet message "Exception.message/1"
@impl true
def message(${1:exception}) do
  $0
end
endsnippet

snippet "n get text(?: 3)?" "Gettext.Backend.ngettext/3" r
ngettext("${1:msgid}", "${2:msgid_plural}", ${3:n})$0
endsnippet

snippet "(?:enum )?random" "Enum.random/1" r
Enum.random(${1:enumerable})$0
endsnippet

snippet tuple "define a literal tuple" i
{${1:first}, ${2:second}$0}
endsnippet

snippet "tuple (.+)" "define a tagged tuple" r
`!p
tag = match.group(1)
`{:`!p snip.rv = tag`, ${1:value}}$0
endsnippet

snippet "validate length" "Ecto.Changeset.validate_length/3"
validate_length(${1:${2:changeset}, }:${3:field}, ${4:is: ${5:length}${6:, }}${7:min: ${8:length}${9:, }}${10:max: ${11:length}${12:, }}${13:count: :${14:length_type}${15:, }}${16:message: "${17:message}"})$0
endsnippet
