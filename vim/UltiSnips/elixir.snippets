extends html
extends eelixir

global !p

import re

_MODULE_FILEPATH = re.compile("lib\/([^\/]+)\/(?:(?:[^\/]+)\/)*([^\/]+).ex")
_DASHES_AND_UNDERSCORES = re.compile("[-_]")

def module_name():
    module_path_parts = _module_path_match().group(1, 2)
    module_parts = map(to_module_name, module_parts)
    return ".".join(module_parts)

def outer_module_name():
    outer_module_path = _module_path_match().group(1)
    return to_module_name(outer_module_path)

def to_module_name(string):
    return (
        re.sub(_DASHES_AND_UNDERSCORES, " ", string)
        .title()
        .replace(" ", "")
    )

def closing_character(opening):
    if opening == "{":
        return "}"
    if opening == "[":
        return "]"
    if opening == "\"":
        return opening

    return ""

def binding_name(match):
    return match.group(1).replace(" ", "-")

# REF path variable: https://github.com/SirVer/ultisnips/blob/master/doc/UltiSnips.txt#L894
def _module_path_match():
    return re.search(_MODULE_FILEPATH, path)

endglobal

snippet "assign 2" "Phoenix.LiveView.assign/2"
assign(socket, ${1:keyword_or_map})$0
endsnippet

snippet "assign 3" "Phoenix.LiveView.assign/3"
assign(socket, :${1:key}, ${2:value})$0
endsnippet

snippet def "define a multiline public function"
def ${1:function_name}${2:(${3:args})} do
  $0
end
endsnippet

snippet "def module" "Defines a module block"
defmodule ${1:`!p snip.rv = module_name()`} do
  $0
end
endsnippet

snippet "def single" "define a single line public function"
def ${1:function_name}${2:(${3:args})}, do: $0
endsnippet

snippet "error tuple" "define an :error tuple"
{:error, ${1:value}}$0
endsnippet

snippet fn "Elixir anonymous function"
fn ${1:args} -> $0 end
endsnippet

snippet "fn &" "Elixir shorthand anonymous function"
&(&1$0)
endsnippet

snippet "handle event" "Phoenix.(LiveView|LiveCompoment).handle_event/3"
@impl true
def handle_event("${1:event}", ${2|params,_unsigned_params|}, socket) do
  $0
  ${3|{:noreply\, socket},{:reply\, reply_map\, socket}|}
end
endsnippet

snippet heex "Phoenix.LiveView.Helpers.sigil_H/2"
~H"""
$0
"""
endsnippet

snippet "IO inspect" "IO.inspect/2"
IO.inspect(${1:item}${2:, ${3:opts}})$0
endsnippet

snippet keyword "Defines a literal Elixir keyword list"
${1:[}${2:key}: ${3:value}$0`!p snip.rv = closing_character(t[1])`
endsnippet

snippet list "Literal Elixir list"
[$0]
endsnippet

snippet "live route" "Defines a LiveView route"
live "/${1:path}", ${2:`!p snip.rv = to_module_name(t[1])`}Live${3:, :${4:action}${5:, ${6:opts}}}$0
endsnippet

snippet map "Defines a literal Elixir map with atom keys"
%{${1:key}: ${2:value}$0}
endsnippet

snippet "map string" "Literal Elixir map with string keys"
%{"${1:key}" => ${2:value}$0}
endsnippet

snippet mount "Phoenix.LiveView.mount/3"
@impl true
def mount(${1|params,_params,:not_mounted_at_router|}, ${2|_session,session|}, socket) do
  $0
  {:ok, socket}
end
endsnippet

snippet "ok tuple" "define an :ok tuple"
{:ok, ${1:value}}$0
endsnippet

snippet "phx (.+)" "phx- binding" r
phx-`!p snip.rv = binding_name(match)`=${1|",{|}$0`!p snip.rv = closing_character(t[1])`
endsnippet

snippet random "Enum.random/1"
Enum.random(${1:enumerable})$0
endsnippet

snippet range "Literal Elixir range" i
${1:first}..${2:last}${3://${4:step}}$0
endsnippet

snippet render "LiveView/LiveComponent render/1"
@impl true
def render(assigns) do
  $0
end
endsnippet

snippet "sigil c" "Kernel.sigil_c/2"
~c(${1:chars})$0
endsnippet

snippet "sigil D" "Kernel.sigil_D/2"
~D[${1:`date +%Y-%m-%d`}]$0
endsnippet

snippet "sigil N" "Kernel.sigil_N/2"
~N[${1:`date "+%Y-%m-%d %T"`}]$0
endsnippet

# https://hexdocs.pm/elixir/1.12/Regex.html#module-modifiers
snippet "sigil r" "Kernel.sigil_r/2"
~r/${2:regex}/${1|f,i,m,s,u,x,U|}$0
endsnippet

snippet "sigil s" "Kernel.sigil_s/2"
~s(${1:string})$0
endsnippet

snippet "sigil T" "Kernel.sigil_T/2"
~T[${1:`date +%T`}]$0
endsnippet

# https://hexdocs.pm/elixir/1.12/Kernel.html#sigil_w/2
snippet "sigil w" "Kernel.sigil_w/2"
~w(${2:words})${1|s,a,c|}$0
endsnippet

snippet "update 3" "Phoenix.LiveView.update/3"
update(${1|socket,assigns|}, :${2:key}, ${3:fun})$0
endsnippet

snippet "use phx" "use Phoenix module"
use ${1:`!p snip.rv = outer_module_name()`}, :${2|channel,component,controller,live_component,live_view,router,view|}$0
endsnippet

snippet "validate length" "ecto validate_length"
validate_length(${1:${2:changeset}, }:${3:field}, ${4:is: ${5:length}${6:, }}${7:min: ${8:length}${9:, }}${10:max: ${11:length}${12:, }}${13:count: :${14:length_type}${15:, }}${16:message: "${17:message}"})$0
endsnippet
